// YACC grammar for ICWS 94 [0]. See [1] for information on the format.
// 0: https://corewar.co.uk/standards/icws94.htm
// 1: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/yacc.html

// Declarations section

// Stuff between %{%} will be copied over verbatim
%{

package parser

import (
	"log/slog"
	"strconv"

	"github.com/pcolladosoto/corewarg/lexer"
)

%}

// Declare the type for values in the stack as well as available
// tag names to declare token and non-terminal types.
%union {
	num int
}

// Declare numeral tokens with the same number as declared in the lexer (i.e. lexer.ItemNumber)
%token <num> NUM 6
%token PLUS 12 // Use ADD (i.e. lexer.ItemADD) as a placeholder for now...
%token EOL 8

%left PLUS

// End the declarations
%%

top: expr EOL {slog.Warn("reduction with expr and EOL")}
	| expr {slog.Warn("reduction with expr w/o EOL")}

expr: expr PLUS expr {slog.Warn("reduction with ADD")}
	| NUM {slog.Warn("reduction with NUM", "NUM", $1)}

%%

// This struct should adhere to the corewarLexer interface:
//
//	type corewarLexer interface {
//		Lex(lval *exprSymType) int
//		Error(s string)
//	}
//
// The interface definition is generated by GoYacc!
// Note the prefix (i.e. coreWar) is provided to goyacc
// through the -p flag.
type corewarLex struct {
	l *lexer.Lexer
}

// Lex should return a new token. It's called by the parser. One
// can set the returned token's value through the reference to
// the exprSymType.
func (x *corewarLex) Lex(yylval *corewarSymType) int {
	ni := x.l.NextItem()
	slog.Debug("got item", "typ", ni.Typ, "val", ni.Val)

	switch ni.Typ {
	case lexer.ItemNumber:
		pInt, err := strconv.ParseInt(ni.Val, 10, 32)
		if err != nil {
			slog.Error("error parsing number %q: %v\n", ni.Val, err)
		}
		yylval.num = int(pInt)

		return int(lexer.ItemNumber)

	case lexer.ItemEOF:
		return 0 // GoYacc expects EOF to be 0

	default:
		return int(ni.Typ)
	}
}

func (x *corewarLex) Error(s string) {
	slog.Error("parse error", "err", s)
}
