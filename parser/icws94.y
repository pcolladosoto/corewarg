// YACC grammar for ICWS 94 [0]. See [1] for information on the format.
// 0: https://corewar.co.uk/standards/icws94.htm
// 1: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/yacc.html

// Declarations section

// Stuff between %{%} will be copied over verbatim
%{

package parser

import (
	"log/slog"
	"strconv"

	"github.com/pcolladosoto/corewarg/lexer"
)

%}

// Declare the type for values in the stack as well as available
// tag names to declare token and non-terminal types.
%union {
	num int
	line string
}

%type <line> instruction

// Declare numeral tokens with the same number as declared in the lexer (i.e. lexer.ItemNumber)
%token <num> NUMBER 6

%token LABEL 1
%token EOL 8

%token <num> DAT 10
%token <num> ADD 12

%token <num> A 27

%token HASH 34

// %left ADD

// End the declarations
%%

assembly_file: list {slog.Warn("reduction at assembly_file with list")}

list: line {slog.Warn("reduction at list with line")}
	| line list {slog.Warn("reduction at list with line, list")}

line: instruction {slog.Warn("reduction at line with instruction", "instruction", $1)}
	| comment {slog.Warn("reduction at line with comment")}

comment: EOL {slog.Warn("reduction at comment with EOL")}

instruction: label_list operation mode comment {slog.Warn("reduction at instruction with label_list, operation, mode, comment")}
	| operation mode comment {slog.Warn("reduction at instruction with label_list, operation, mode, comment")}
	| label_list operation mode expr mode expr comment {slog.Warn("reduction at instruction with label_list, operation, mode, expr, mode, expr, comment")}
	| operation mode expr mode expr comment {slog.Warn("reduction at instruction with label_list, operation, mode, expr, mode, expr, comment")}

label_list: LABEL {slog.Warn("reduction at label_list with LABEL")}
	| LABEL label_list {slog.Warn("reduction at label_list with LABEL, label_list")}
	| LABEL EOL label_list {slog.Warn("reduction at label_list with LABEL, EOL")}
	// | /* empty */  {slog.Warn("reduction at label_list with EMPTY")} // This causes shift/reduce conflicts!

operation: opcode {slog.Warn("reduction at operation with opcode")}
	| opcode modifier  {slog.Warn("reduction at operation with opcode, modifier")}

opcode: ADD {slog.Warn("reduction at opcode with ADD", "ADD", $1)}
	| DAT {slog.Warn("reduction at opcode with DAT", "DAT", $1)}

modifier: A {slog.Warn("reduction at modifier with A", "A", $1)}

mode: HASH {slog.Warn("reduction at mode with HASH")}

expr: term {slog.Warn("reduction at expr with term")}

term: LABEL {slog.Warn("reduction at term with LABEL")}
	| NUMBER {slog.Warn("reduction at term with NUMBER")}

%%

// This struct should adhere to the corewarLexer interface:
//
//	type corewarLexer interface {
//		Lex(lval *exprSymType) int
//		Error(s string)
//	}
//
// The interface definition is generated by GoYacc!
// Note the prefix (i.e. coreWar) is provided to goyacc
// through the -p flag.
type corewarLex struct {
	l *lexer.Lexer
}

// Lex should return a new token. It's called by the parser. One
// can set the returned token's value through the reference to
// the exprSymType.
func (x *corewarLex) Lex(yylval *corewarSymType) int {
	ni := x.l.NextItem()
	slog.Info("got item", "typ", ni.Typ, "val", ni.Val)

	switch ni.Typ {
	case lexer.ItemNumber:
		pInt, err := strconv.ParseInt(ni.Val, 10, 32)
		if err != nil {
			slog.Error("error parsing number %q: %v\n", ni.Val, err)
		}
		yylval.num = int(pInt)

		return int(lexer.ItemNumber)

	case lexer.ItemEOF:
		return 0 // GoYacc expects EOF to be 0

	default:
		return int(ni.Typ)
	}
}

func (x *corewarLex) Error(s string) {
	slog.Error("parse error", "err", s)
}
